＃Redis配置文件示例。
＃
＃注意，为了读取配置文件，Redis必须是
＃以文件路径作为第一个参数开头：
＃
＃./redis-server /path/to/redis.conf

＃关于单位的注释：需要内存大小时，可以指定
＃以通常的1k 5GB 4M格式，依此类推：
＃
＃1k => 1000字节
＃1kb => 1024字节
＃1m => 1000000字节
＃1mb => 1024 * 1024字节
＃1g => 1000000000字节
＃1gb => 1024 * 1024 * 1024字节
＃
＃单位不区分大小写，因此1GB 1Gb 1gB都相同。

############################### INCLUDES ################ ####################

＃在此处包含一个或多个其他配置文件。如果您
＃具有可用于所有Redis服务器的标准模板，但也需要
＃自定义一些每服务器设置。包含文件可以包括
＃个其他文件，因此请明智地使用此文件。
＃
＃注意选项“ include”不会被命令“ CONFIG REWRITE”重写
＃来自admin或Redis Sentinel。由于Redis始终使用最后处理的
＃将line作为配置指令的值，最好将include
＃在此文件的开头，以避免在运行时覆盖配置更改。
＃
＃如果您有兴趣使用include覆盖配置
＃选项，最好使用include作为最后一行。
＃
＃包括/path/to/local.conf
＃包括/path/to/other.conf

#################################模块############### ######################

＃在启动时加载模块。如果服务器无法加载模块
＃它会中止。可以使用多个loadmodule指令。
＃
＃loadmodule /path/to/my_module.so
＃loadmodule /path/to/other_module.so

################################ NETWORK ############### ######################

＃默认情况下，如果未指定“ bind”配置指令，则Redis侦听
＃用于来自服务器上所有可用网络接口的连接。
＃可以使用以下方法仅收听一个或多个选定的接口
＃“ bind”配置指令，后接一个或多个IP地址。
＃
＃ 例子：
＃
＃绑定192.168.1.100 10.0.0.1
＃绑定127.0.0.1 :: 1
＃
＃~~~警告~~~如果运行Redis的计算机直接暴露于
＃互联网，绑定到所有接口都是危险的，并且会暴露
＃实例给互联网上的所有人。因此，默认情况下，我们取消注释
＃遵循bind指令，这将强制Redis仅侦听
＃IPv4环回接口地址（这意味着Redis将能够
＃只接受来自同一台计算机上运行的客户端的连接
＃ 在跑）。
＃
＃如果您确定要立即侦听所有界面
＃只需注意以下几行。
＃~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~
绑定127.0.0.1

＃保护模式是一层安全保护，以避免
＃访问和利用Internet上打开的Redis实例。
＃
＃启用保护模式时，如果：
＃
＃1）服务器未使用以下命令明确绑定到一组地址
＃“ bind”指令。
＃2）未配置密码。
＃
＃服务器仅接受来自客户端的连接，这些客户端从
＃IPv4和IPv6回送地址127.0.0.1和:: 1，并且来自Unix域
＃个套接字。
＃
＃默认情况下启用保护模式。只有在以下情况下才应禁用它
＃您确定要让其他主机的客户端连接到Redis
＃即使没有配置身份验证，也没有特定的接口集
＃使用“ bind”指令显式列出。
保护模式是

＃接受指定端口上的连接，默认为6379（IANA＃815344）。
＃如果指定了端口0，则Redis将不会在TCP套接字上侦听。
端口6379

＃TCP listen（）积压。
＃
＃在高每秒请求数的环境中，您需要大量积压订单
＃避免客户端连接速度慢的问题。注意Linux内核
＃将默默地将其截断为/ proc / sys / net / core / somaxconn的值，因此
＃确保同时提高somaxconn和tcp_max_syn_backlog的值
＃以获得预期的效果。
tcp积压511

＃Unix套接字。
＃
＃指定用于侦听的Unix套接字的路径
＃传入连接。没有默认设置，因此Redis不会收听
如果未指定，则在Unix套接字上使用＃号。
＃
＃unixsocket /tmp/redis.sock
＃unixsocketperm 700

＃客户端闲置N秒后关闭连接（0禁用）
超时0

＃TCP保持活动状态。
＃
＃如果不为零，请使用SO_KEEPALIVE向不存在的客户端发送TCP ACK
通信数量。这很有用，原因有两个：
＃
＃1）检测死亡的同伴。
＃2）从网络角度来看，保持连接活跃
＃设备在中间。
＃
＃在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。
＃请注意，关闭连接需要两倍的时间。
＃在其他内核上，期限取决于内核配置。
＃
＃此选项的合理值为300秒，这是新的
＃Redis默认从Redis 3.2.1开始。
tcp-keepalive 300

＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃ 一般 ＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃ #####################

＃默认情况下，Redis不会作为守护程序运行。如果需要，请使用“是”。
＃注意，Redis守护进程将在/var/run/redis.pid中写入一个pid文件。
守护没有

＃如果您是从upstart或systemd运行Redis，则Redis可以与您的
＃监督树。选项：
＃无监督-无监督互动
＃受监督的新贵-通过将Redis置于SIGSTOP模式来指示新贵
＃受监督的systemd-通过将READY = 1写入$ NOTIFY_SOCKET来发出信号systemd
＃有监督的自动-基于以下命令检测暴发户或系统方法
＃UPSTART_JOB或NOTIFY_SOCKET环境变量
＃注意：这些监视方法仅表示“过程已准备就绪”。
＃他们无法使您的主管连续不断地进行ping操作。
有监督的

＃如果指定了pid文件，则Redis会在启动时将其写入指定位置
＃并在出口处将其删除。
＃
＃当服务器以非守护进程运行时，如果没有，则不创建pid文件
＃在配置中指定。守护服务器时，pid文件
即使未指定，也会使用＃，默认为“ /var/run/redis.pid”。
＃
＃尽力创建一个pid文件：如果Redis无法创建它
＃一切正常，服务器将启动并正常运行。
pidfile /var/run/redis_6379.pid

＃指定服务器的详细级别。
＃这可以是以下之一：
＃调试（很多信息，对于开发/测试很有用）
＃详细（很多很少有用的信息，但不会像调试级别那样混乱）
＃通知（适度冗长，可能在生产中需要什么）
＃警告（仅记录非常重要/重要的消息）
日志级别通知

＃指定日志文件名。也可以使用空字符串强制
＃Redis登录到标准输出。请注意，如果您使用标准
＃输出用于日志记录但要守护进程，日志将发送到/ dev / null
日志文件“”

＃要启用到系统记录器的日志记录，只需将'syslog-enabled'设置为yes，
＃并根据需要更新其他syslog参数。
＃启用syslog否

＃指定系统日志标识。
＃syslog-ident redis

＃指定系统日志工具。必须是USER或在LOCAL0-LOCAL7之间。
＃syslog-facility local0

＃设置数据库数量。默认数据库是DB 0，可以选择
＃使用SELECT <dbid>在每个连接的基础上不同
＃dbid是介于0和'databases'-1之间的数字
数据库16

＃默认情况下，Redis仅在开始登录时才显示ASCII艺术徽标。
＃标准输出，如果标准输出是TTY。基本上这意味着
＃通常徽标仅在交互式会话中显示。
＃
＃但是可以强制4.0之前的行为并始终显示
＃通过将以下选项设置为yes，以在启动日志中显示ASCII艺术徽标。
总是显示徽标是

##############################快照################# ###############
＃
＃将数据库保存在磁盘上：
＃
＃保存<seconds> <changes>
＃
＃如果给定的秒数和给定的秒数都将保存数据库
＃针对数据库的写入操作数。
＃
＃在下面的示例中，行为将是保存：
＃在900秒（15分钟）后，如果至少更改了1个键
＃300秒（5分钟）后，如果至少更改了10个按键
＃60秒后，如果至少更改了10000个键
＃
＃注意：您可以通过注释掉所有“保存”行来完全禁用保存。
＃
＃也可以删除所有先前配置的保存
通过添加带有单个空字符串参数的save指令获得＃点
＃如以下示例所示：
＃
＃ 救 ””

节省900 1
节省300 10
节省60 10000

＃默认情况下，如果启用了RDB快照，Redis将停止接受写入
＃（至少一个保存点），并且最新的后台保存失败。
＃这将使用户（很难）知道数据没有持久化
＃正确地放在磁盘上，否则没有人会注意到，有的机会
＃灾难将会发生。
＃
＃如果后台保存过程将再次开始工作，则Redis将
＃自动允许再次写入。
＃
＃但是，如果您已经设置了对Redis服务器的适当监视
＃和持久性，您可能要禁用此功能，以便Redis将
＃即使磁盘出现问题，仍继续照常工作，
＃权限，依此类推。
停止在bgsave上写入错误是

＃转储.rdb数据库时使用LZF压缩字符串对象？
＃默认情况下将其设置为“是”，因为它几乎总是胜利。
＃如果要在保存子项中保存一些CPU，请将其设置为“ no”，但是
＃如果您具有可压缩的值或键，则数据集可能会更大。
rdbcompression是

＃从RDB版本5开始，在文件末尾放置了CRC64校验和。
＃这可以使格式更耐腐败，但性能
＃保存和加载RDB文件时点击付费（大约10％），因此您可以将其禁用
＃以获得最佳性能。
＃
＃在禁用校验和的情况下创建的RDB文件的校验和为零，这将使
＃告诉加载代码跳过检查。
rdbchecksum是

＃转储数据库的文件名
dbfilename dump.rdb

＃工作目录。
＃
＃数据库将被写入此目录，并指定文件名
＃以上使用'dbfilename'配置指令。
＃
＃也将在此目录中创建“仅追加文件”。
＃
＃请注意，您必须在此处指定目录，而不是文件名。
目录./

############################### REPLICATION ################ #################

＃主副本复制。使用copyof作为Redis实例的副本
＃另一个Redis服务器。尽快了解有关Redis复制的几件事。
＃
＃+ ------------------ + + --------------- +
＃| 硕士 ---> | 复制品|
＃| （接收写入）| | （精确副本）|
＃+ ------------------ + + --------------- +
＃
＃1）Redis复制是异步的，但是您可以将master配置为
＃如果至少看起来没有连接，则停止接受写入
＃给定数量的副本。
＃2）Redis副本能够与以下服务器执行部分重新同步
＃master（如果复制链接丢失了相对较少的数量）
＃ 时间。您可能要配置复制积压大小（请参阅下一个
此文件的＃个部分），根据您的需要具有合理的价值。
＃3）复制是自动的，不需要用户干预。之后
＃网络分区副本自动尝试重新连接到主数据库
＃并与它们重新同步。
＃
＃复制<masterip> <masterport>

＃如果主服务器受密码保护（使用“ requirepass”配置）
下面的＃指令）可以告诉副本在进行身份验证之前
＃启动复制同步过程，否则主服务器将
＃拒绝副本请求。
＃
＃masterauth <主密码>
＃
＃但是，如果您使用的是Redis ACL（对于Redis版本，则还不够）
＃6或更高版本），并且默认用户无法运行PSYNC
＃命令和/或复制所需的其他命令。在这种情况下
＃更好地配置特殊用户以用于复制，并指定
＃masteruser配置如下：
＃
＃masteruser <用户名>
＃
＃指定masteruser时，副本将根据其身份验证
＃master使用新的AUTH形式：AUTH <用户名> <密码>。

＃副本失去与主数据库的连接或复制时
＃仍在进行中，副本可以以两种不同的方式起作用：
＃
＃1）如果复制副本服务过时数据设置为“是”（默认值），则复制副本将
＃仍然会回复客户的请求，可能包含过期的数据，或者
如果这是第一次同步，则＃数据集可能只是空的。
＃
＃2）如果复制副本服务过时数据设置为“否”，复制副本将回复
＃对所有类型的命令均出现错误“正在与主机进行同步”
＃，但要添加到INFO，replicaOF，AUTH，PING，SHUTDOWN，REPLCONF，ROLE，CONFIG，
＃SUBSCRIBE，UNSUBSCRIBE，PSUBSCRIBE，PUNSUBSCRIBE，PUBLISH，PUBSUB，
＃COMMAND，POST，HOST：和延迟。
＃
复制服务过时数据是

＃您可以配置副本实例以接受或不接受写入。反对
＃复制副本实例可能有助于存储一些临时数据（因为数据
与主服务器重新同步后，写在副本上的＃将很容易删除），但是
如果客户由于以下原因写信，＃也会引起问题。
＃配置错误。
＃
＃由于Redis 2.6默认情况下，副本是只读的。
＃
＃注意：只读副本并非旨在向不受信任的客户端公开
＃ 在网上。它只是防止实例滥用的保护层。
＃默认情况下，仍然是只读副本导出所有管理命令
＃，例如CONFIG，DEBUG等。在一定程度上您可以改善
＃使用'rename-command'隐藏所有副本的只读副本的安全性
＃行政/危险命令。
副本只读是

＃复制同步策略：磁盘或套接字。
＃
＃无法继续执行新副本和重新连接副本
＃复制过程刚刚收到差异，需要做的是所谓的
＃“完全同步”。RDB文件从主机传输到
＃个副本。
＃
＃传输可以两种不同的方式发生：
＃
＃1）支持磁盘：Redis主服务器创建一个新过程，该过程写入RDB
＃文件在磁盘上。之后文件由父级传输
＃逐步处理副本。
＃2）无盘：Redis主服务器创建一个新进程，该进程直接写入
＃将RDB文件复制到副本套接字，而完全不接触磁盘。
＃
＃使用磁盘支持的复制时，在生成RDB文件时，会有更多副本
＃可以在当前子级中排入队列并与RDB文件一起使用
＃生成RDB文件完成其工作。改为使用无盘复制
＃传输开始后，新的副本将进入队列，并且新
＃传输将在当前传输终止时开始。
＃
＃使用无盘复制时，主服务器等待可配置数量的
＃开始传输之前的时间（以秒为单位），希望倍数
＃副本将到达，并且传输可以并行化。
＃
＃使用慢速磁盘和快速（大带宽）网络时，无盘复制
＃效果更好。
repl-diskless-sync否

＃启用无盘复制后，可以配置延迟
＃服务器等待以生成通过套接字传输RDB的子代
＃复制到副本。
＃
＃这很重要，因为一旦转移开始，就无法提供服务
＃个新副本到达，将排队等待下一次RDB传输，因此
＃服务器等待延迟以便让更多副本到达。
＃
＃以秒为单位指定延迟，默认为5秒。禁用
＃完全将其设置为0秒，传输将尽快开始。
repl-diskless-sync-delay 5

＃------------------------------------------------- ----------------------------
＃警告：RDB无盘加载是实验性的。由于在此设置中，副本
＃不会立即将RDB存储在磁盘上，这可能会导致数据丢失
＃故障转移。RDB无盘负载+ Redis模块不处理I / O读取也可能
＃导致Redis在初始同步期间发生I / O错误时中止
＃舞台与高手。仅在执行自己的操作时使用。
＃------------------------------------------------- ----------------------------
＃
＃复制副本可以直接从复制链接加载从复制链接读取的RDB
＃套接字，或将RDB存储到文件中，并在文件完全读取后读取
＃从主人那里获得。
＃
＃在许多情况下，磁盘的速度比网络慢，并且存储和加载速度
＃RDB文件可能会增加复制时间（甚至会增加主数据库的复制时间
＃复制写入内存和从缓冲区。
＃但是，直接从套接字解析RDB文件可能意味着我们拥有
＃在完整的rdb被清除之前刷新当前数据库的内容
＃收到。因此，我们有以下选择：
＃
＃“ disabled”-不要使用无盘负载（首先将rdb文件存储到磁盘）
＃“ on-empty-db”-仅在完全安全时才使用无盘加载。
＃“ swapdb”-解析时在RAM中保留当前数据库内容的副本
＃直接从套接字获取数据。请注意，这需要
＃足够的内存，如果没有足够的内存，则可能会杀死OOM。
repl-diskless-load已禁用

＃副本以预定义的时间间隔将PING发送到服务器。有可能
＃使用repl_ping_replica_period选项更改此间隔。默认值
＃值为10秒。
＃
＃repl-ping-replica-period 10

＃以下选项为以下项设置复制超时：
＃
＃1）从副本的角度来看，在SYNC期间进行批量传输I / O。
＃2）从副本（数据，Ping）的角度来看，主超时。
＃3）从主服务器角度来看，副本超时（REPLCONF ACK ping）。
＃
＃确保此值大于该值很重要
＃为repl-ping-replica-period指定，否则将检测到超时
＃每次主服务器和副本服务器之间的流量较低时。
＃
＃repl-timeout 60

＃在SYNC之后禁用副本套接字上的TCP_NODELAY？
＃
＃如果选择“是”，则Redis将使用较少数量的TCP数据包，并且
＃减少将数据发送到副本的带宽。但这可能会增加
＃数据出现在副本端，最多40毫秒，
＃Linux内核使用默认配置。
＃
＃如果选择“否”，则数据在副本端出现的延迟将
＃减少，但是将使用更多带宽进行复制。
＃
＃默认情况下，我们针对低延迟进行了优化，但在流量非常高的情况下
＃或在距离主副本和副本很多跳的情况下，将其设置为“是”
＃成为一个好主意。
repl-disable-tcp-nodelay否

＃设置复制积压大小。积压是积累的缓冲区
＃副本断开连接一段时间后的副本数据，以便当
＃复制副本想重新连接，通常不需要完全重新同步，但是
＃部分重新同步就足够了，只需将部分数据传递给副本
＃断开连接时错过了。
＃
＃复制待办事项越大，副本可以停留的时间越长
＃已断开连接，以后可以执行部分​​重新同步。
＃
＃仅在至少连接一个副本后才分配积压。
＃
＃repl-backlog-size 1mb

＃在主服务器一段时间不再连接副本后，积压
＃将被释放。以下选项配置了秒数
从最后一个副本断开连接的时间开始，需要＃
＃待释放的待办事项缓冲区。
＃
＃注意副本不会释放积压的超时，因为它们可能是
＃稍后晋升为大师，应该能够正确地“部分
＃resyncize”与副本：因此它们应始终累积积压。
＃
＃值0表示从不释放积压。
＃
＃repl-backlog-ttl 3600

＃副本优先级是Redis在INFO中发布的整数
＃输出。Redis Sentinel使用它来选择要升级的副本
＃如果主服务器不再正常工作，则进入主服务器。
＃
＃优先级低的副本被认为更适合升级，因此
＃例如，如果有三个副本的优先级分别为10、100、25 Sentinel
＃将选择优先级为10的优先级最低的那个。
＃
＃但是，特殊优先级0表示副本无法执行
＃为主角色，因此优先级为0的副本永远不会被
＃Redis前哨升级。
＃
＃默认情况下，优先级为100。
副本优先级100

＃如果少于以下数量，则主服务器可能会停止接受写入
已连接N个副本，延迟小于或等于M秒。
＃
＃N个副本必须处于“联机”状态。
＃
＃必须以秒为单位的滞后时间必须小于等于指定值，计算公式为
＃从副本接收到的最后ping，通常每秒发送一次。
＃
＃此选项不能保证N个副本将接受写入，但是
＃如果副本数量不足，则会限制丢失写入的窗口
＃可用，以指定的秒数为单位。
＃
＃例如，至少需要3个滞后<= 10秒的副本，请使用：
＃
＃min-replicas-to-write 3
＃min-replicas-max-lag 10
＃
＃将其中一个设置为0将禁用该功能。
＃
＃默认情况下，min-replicas-to-write设置为0（禁用功能），并且
＃min-replicas-max-lag设置为10。

＃Redis主服务器能够列出连接的地址和端口
＃以不同方式复制。例如，“ INFO复制”部分
＃提供此信息，除其他工具外，该信息还用于
＃Redis Sentinel以发现副本实例。
＃此信息可用的另一个地方是
＃主站的“ ROLE”命令。
＃
＃获取通常由副本报告的列出的IP和地址
＃以下列方式：
＃
＃IP：通过检查对等地址自动检测到该地址
副本用于与主服务器连接的套接字的编号。
＃
＃端口：端口在复制过程中由副本进行通信
＃握手，通常是副本使用的端口
＃监听连接。
＃
＃但是，当端口转发或网络地址转换（NAT）为
＃使用，副本实际上可以通过不同的IP和端口访问
＃对。副本可以使用以下两个选项，以便
＃向其主控报告一组特定的IP和端口，以便双方
＃和ROLE将报告这些值。
＃
＃如果您只需要覆盖两个选项，则无需同时使用这两个选项
＃端口或IP地址。
＃
＃副本公告IP 5.5.5.5
＃副本通告端口1234

#############################按键跟踪################# ################

＃Redis为客户端的值缓存实现服务器辅助的支持。
＃这是通过使用记住的无效表实现的
＃1600万个插槽，哪些客户端可能具有某些密钥子集。反过来
＃这用于为了发送无效消息到客户端。请
＃要了解有关此功能的更多信息，请检查以下页面：
＃
＃https://redis.io/topics/client-side-caching
＃
＃为客户端启用跟踪时，将假定所有只读查询
＃要缓存：这将迫使Redis在无效信息中存储信息
＃表。修改密钥后，此类信息将被清除，并且
＃无效消息发送到客户端。但是，如果工作量为
＃在读取中占主导地位，Redis可以按顺序使用越来越多的内存
＃跟踪许多客户端获取的密钥。
＃
＃因此，可以为
＃无效表。默认情况下，它设置为10％，一旦达到此限制
到达＃号，Redis将开始驱逐失效表中的缓存插槽
＃即使未修改密钥，也只是为了回收内存：这将依次
＃强制客户端使缓存的值无效。基本上是桌子
＃最大填充率是您要花费的服务器内存之间的折衷
＃端跟踪有关谁缓存了什么以及客户端功能的信息
＃在内存中保留缓存的对象。
＃
＃如果将值设置为0，则表示没有限制，所有16个
可以同时使用＃百万个缓存插槽。在“统计信息”中
在＃INFO部分中，您可以找到有关高速缓存插槽数量的信息
＃在每个给定的时刻使用。
＃
＃tracking-table-max-fill 10

################################# SECURITY ################ ####################

＃警告：由于Redis相当快，外部用户可以尝试
＃在现代机器上每秒可读取100万个密码。这意味着你
＃应该使用非常强壮的密码，否则它们很容易被破解。
＃注意，因为密码实际上是客户端之间的共享机密
＃和服务器，并且不应被任何人记住密码
＃可以很容易地是来自/ dev / urandom或其他类型的长字符串，因此可以使用
＃长而难以猜测的密码，无法进行暴力攻击。

＃Redis ACL用户的定义如下：
＃
＃user <用户名> ... acl规则...
＃
＃ 例如：
＃
＃用户工作者+ @ list + @ connection〜jobs：* on> ffa9203c493aa99
＃
＃特殊用户名“默认”用于新连接。如果这个用户
＃具有“ nopass”规则，那么新连接将立即得到认证
＃作为“默认”用户，而无需通过
＃AUTH命令。否则，如果未将“默认”用户标记为“ nopass”
＃连接将以未经身份验证的状态开始，并且需要
＃AUTH（或HELLO命令AUTH选项），以便进行身份验证和
＃开始工作。
＃
＃描述用户可以执行的操作的ACL规则如下：
＃
＃on启用用户：可以以该用户身份进行身份验证。
＃off禁用用户：不再可以进行身份​​验证
＃与该用户，但是已经通过身份验证的连接
＃仍然可以使用。
＃+ <命令>允许执行该命令
＃-<命令>禁止执行该命令
＃+ @ <category>允许执行此类中的所有命令
具有有效类别的＃就像@ admin，@ set，@ sortedset，...
＃依此类推，请参阅server.c文件中的完整列表，其中
＃描述并定义了Redis命令表。
＃特殊类别@all表示所有命令，但当前
＃存在于服务器中，以后会加载
＃通过模块。
＃+ <command> | subcommand允许使用否则的特定子命令
＃禁用命令。请注意，此表格不是
＃可以像-DEBUG | SEGFAULT一样被否定，但是
＃仅以“ +”开头的添加剂。
＃allcommands + @ all的别名。请注意，这意味着执行的能力
＃所有将来通过模块系统加载的命令。
＃nocommands-@ all的别名。
＃〜<pattern>添加可以在其中提及的键的模式
＃条命令。例如〜*允许所有键。模式
＃是类似于KEYS之一的glob样式的模式。
＃可以指定多个模式。
＃allkeys〜*的别名
＃resetkeys刷新允许的键模式列表。
＃> <密码>将此密码添加到用户的有效密码列表中。
＃例如> mypass将“ mypass”添加到列表中。
＃此指令清除“ nopass”标志（请参阅下文）。
＃<< password>从有效密码列表中删除此密码。
＃nopass删除用户的所有设置密码，然后用户
＃被标记为不需要密码：这意味着每个
＃密码将对此用户无效。如果该指令是
＃用于默认用户，每个新连接都会
＃立即通过默认用户进行身份验证，而无需
＃任何必需的显式AUTH命令。注意“ resetpass”
＃指令将清除此条件。
＃resetpass刷新允许的密码列表。而且去除
＃“ nopass”状态。在“ resetpass”之后，用户没有关联
＃个密码，没有添加就无法进行身份验证
＃一些密码（或稍后将其设置为“ nopass”）。
＃reset执行以下操作：resetpass，resetkeys，off，
＃-@ all。用户立即返回到相同的状态
＃创建后。
＃
＃ACL规则可以以任何顺序指定：例如，您可以以
＃个密码，然后是标志或密钥模式。但是请注意，添加剂
＃和减法规则将根据顺序更改含义。
＃例如，请参见以下示例：
＃
＃用户alice在+ @ all -DEBUG〜*> somepassword上
＃
＃这将允许“驴友”使用所有命令，但
＃DEBUG命令，因为+ @ all将所有命令添加到命令集中
＃alice可以使用，后来删除了DEBUG。但是，如果我们颠倒顺序
如果有两个ACL规则，结果将有所不同：
＃
＃用户alice在-DEBUG + @ all〜*> somepassword
＃
＃现在，当alice在允许的集中还没有命令时，DEBUG被删除。
＃命令，以后添加了所有命令，因此用户将能够
＃执行所有操作。
＃
＃基本上，ACL规则是从左到右处理的。
＃
＃有关ACL配置的更多信息，请参阅
＃Redis网站位于https://redis.io/topics/acl

＃使用外部ACL文件
＃
＃可以在此文件中代替在此处配置用户
＃一个仅列出用户的独立文件。两种方法不能混合使用：
＃如果您在此处配置用户并同时激活外部
＃ACL文件，服务器将拒绝启动。
＃
＃外部ACL用户文件的格式与
＃在redis.conf中用于描述用户的格式。
＃
＃aclfile /etc/redis/users.acl

＃重要说明：从Redis 6开始，“ requirepass”只是一种兼容性
在新的ACL系统之上的＃层。选项效果将只是设置
＃默认用户的密码。客户仍将使用
＃像往常一样使用AUTH <password>，或更明确地使用AUTH default <password>
＃如果它们遵循新协议：两者都会起作用。
＃
＃requirepass foobared

＃命令重命名（不建议使用）。
＃
＃------------------------------------------------- -----------------------
＃警告：尽可能避免使用此选项。而是使用ACL移除
＃个来自默认用户的命令，并将它们仅放置在您的某些管理员用户中
＃创建用于管理目的。
＃------------------------------------------------- -----------------------
＃
＃可以在共享中更改危险命令的名称
＃ 环境。例如，可以将CONFIG命令重命名为某些内容
＃难以猜测，因此仍可用于内部使用工具
＃但不适用于一般客户。
＃
＃示例：
＃
＃重命名命令CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
＃
＃也可以通过将命令重命名为命令来完全杀死命令
＃一个空字符串：
＃
＃重命名命令CONFIG“”
＃
＃请注意，更改登录到
＃AOF文件或传输到副本可能会导致问题。

################################# CLIENTS ############## ######################

＃设置同时连接的最大客户端数。默认
＃此限制设置为10000个客户端，但是如果Redis服务器不是
＃能够配置进程文件限制以允许指定的限制
＃允许的最大客户端数设置为当前文件限制
＃减32（因为Redis保留了一些文件描述符供内部使用）。
＃
＃一旦达到限制，Redis将关闭所有新发送的连接
＃错误“达到最大客户端数”。
＃
＃maxclients 10000

＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃ 内存管理 ＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃ ##############

＃设置内存使用限制为指定的字节数。
＃当达到内存限制时，Redis将尝试删除密钥
＃根据选择的驱逐策略（请参阅maxmemory-policy）。
＃
＃如果Redis无法根据策略删除密钥，或者策略为
＃设置为'noeviction'，Redis将开始回复命令错误
＃将使用更多的内存，例如SET，LPUSH等，并将继续
＃回复诸如GET之类的只读命令。
＃
＃当将Redis用作LRU或LFU缓存或将
＃设置实例的硬盘限制（使用“ noeviction”策略）。
＃
＃警告：如果您将副本附加到实例上且具有maxmemory，
＃减去提供副本所需的输出缓冲区的大小
＃从已用的内存数量开始，以便网络问题/重新同步
＃不触发退出键的循环，反过来输出
＃副本缓冲区已满，有被删除的密钥DEL触发了删除
＃更多密钥，依此类推，直到数据库完全清空。
＃
＃简而言之...如果您附加了副本，建议您设置一个较低的
＃maxmemory的限制，以便系统上有一些可用的RAM用于复制
＃个输出缓冲区（但是，如果策略为“ noeviction”，则不需要这样做）。
＃
＃maxmemory <字节>

＃MAXMEMORY POLICY：maxmemory时，Redis将如何选择要删除的内容
＃ 到达了。您可以选择以下五种行为：
＃
＃volatile-lru->使用具有过期集的密钥中的近似LRU进行驱逐。
＃allkeys-lru->使用近似的LRU退出任何密​​钥。
＃volatile-lfu->使用具有过期集的键中的近似LFU退出。
＃allkeys-lfu->使用近似的LFU退出任何密​​钥。
＃volatile-random->从具有过期集的密钥中删除一个随机密钥。
＃allkeys-random->删除随机密钥，任何密钥。
＃volatile-ttl->删除最接近到期​​时间（较小的TTL）的密钥
＃noeviction->不要逐出任何东西，只需在写操作中返回错误。
＃
＃LRU表示最近最少使用
＃LFU表示最少使用
＃
＃LRU，LFU和volatile-ttl均使用近似值实现
＃随机算法。
＃
＃注意：使用上述任何策略，Redis都会在写入时返回错误
＃操作，如果没有合适的退出键。
＃
＃在撰写本文时，这些命令是：set setnx setex append
＃incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
＃sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
＃zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
＃getset mset msetnx exec排序
＃
＃默认为：
＃
＃maxmemory-policy noeviction

＃LRU，LFU和最小TTL算法不是精确算法，而是近似算法
＃算法（以节省内存），因此您可以对其进行调整以提高速度或
＃ 准确性。默认情况下，Redis将检查五个键并选择一个
＃最近使用较少，您可以使用以下方法更改样本大小
＃配置指令。
＃
＃默认值5产生足够好的结果。10非常接近
＃真正的LRU，但需要更多的CPU。3更快，但不是很准确。
＃
＃maxmemory-samples 5

＃从Redis 5开始，默认情况下，副本将忽略其maxmemory设置
＃（除非在故障转移后或手动升级为主服务器）。它的意思是
＃退出密钥将仅由主机处理，发送
＃DEL命令将副本作为副本在主控端退出。
＃
＃此行为可确保母版和副本保持一致，并且通常
＃您想要的内容，但是如果副本是可写的，或者您想要副本
＃具有不同的内存设置，并且您确定执行了所有写操作
＃到副本是幂等的，则可以更改此默认值（但请确保
＃了解您在做什么。
＃
＃请注意，由于默认情况下该副本不会逐出，因此可能会使用更多副本
＃内存比通过maxmemory设置的内存多（某些缓冲区可能
＃在副本上更大，否则数据结构有时可能会占用更多内存
＃等）。因此，请确保您监视副本并确保它们
＃具有足够的内存，永远不会在内存不足之前达到真正的内存不足状态
＃master达到配置的maxmemory设置。
＃
＃复制副本忽略最大内存是

############################ LAZY FREEING #################### #################

＃Redis有两个删除键的原语。一个叫做DEL，是一个阻塞
＃删除对象。这意味着服务器停止处理新命令
＃为了在同步中回收与对象关联的所有内存
＃ 方式。如果删除的键与小对象相关联，则需要时间
＃为了执行DEL命令非常小，可以与大多数其他设备相比
＃Redis中的O（1）或O（log_N）命令。但是，如果密钥与
＃包含数百万个元素的聚合值，服务器可以阻止
＃长时间（甚至几秒钟）以完成操作。
＃
＃由于上述原因，Redis还提供了非阻塞删除原语
＃，例如UNLINK（非阻塞DEL）和FLUSHALL的ASYNC选项，以及
＃FLUSHDB命令，以便在后台回收内存。这些命令
＃在固定时间内执行。另一个线程将逐步释放
＃尽可能快地在后台对象。
＃
＃FLUSHALL和FLUSHDB的DEL，UNLINK和ASYNC选项是用户控制的。
＃由应用程序的设计来了解何时是一个好的选择
＃使用一个或另一个的想法。但是，Redis服务器有时必须
＃删除键或刷新整个数据库，这是其他操作的副作用。
＃特别是Redis会独立于用户调用中的对象删除对象
＃以下方案：
＃
＃1）驱逐时，由于maxmemory和maxmemory策略配置，
＃以便为新数据腾出空间，而无需遍历指定的
＃内存限制。
＃2）由于过期：当密钥与相关的生存时间有关（请参见
＃EXPIRE命令）必须从内存中删除。
＃3）由于将数据存储在键上的命令的副作用，该键可能会
＃ 已经存在。例如，RENAME命令可能会删除旧密钥
＃内容被另一个替换时。同样的SUNIONSTORE
＃或带有STORE选项的SORT可能会删除现有密钥。SET命令
＃本身会删除指定密钥的所有旧内容以进行替换
＃使用指定的字符串。
＃4）在复制过程中，当副本执行完全重新同步时，
＃它的主人，整个数据库的内容被删除以便
＃加载刚传输的RDB文件。
＃
＃在上述所有情况下，默认设置都是以阻止方式删除对象，
＃就像是否调用了DEL。但是，您可以专门配置每种情况
＃以便以非阻塞方式释放内存，例如UNLINK
使用以下配置指令调用了＃：

懒惰-懒惰驱逐
lazyfree-lazyexpire否
lazyfree-lazy-server-del no
副本懒惰刷新否

############################ APPEND ON MODE ################# ##############

＃默认情况下，Redis异步将数据集转储到磁盘上。此模式是
＃在许多应用程序中都足够好，但是Redis进程或
＃停电可能会导致几分钟的写入丢失（取决于
＃配置的保存点）。
＃
＃仅附加文件是一种替代的持久性模式，可提供
＃更好的耐久性。例如使用默认数据fsync策略
＃（请参阅配置文件中的后面部分），Redis可能仅丢失一秒钟的写操作。
＃戏剧性事件，例如服务器断电，或者一次写入（如果有的话）
＃Redis进程本身发生了错误，但是操作系统是
＃仍能正常运行。
＃
＃可以同时启用AOF和RDB持久性，而不会出现问题。
＃如果启动时启用了AOF，则Redis将加载AOF，即文件
＃具有更好的耐用性保证。
＃
＃请检查http://redis.io/topics/persistence了解更多信息。

appendonly否

＃仅附加文件的名称（默认值：“ appendonly.aof”）

appendfilename“ appendonly.aof”

＃fsync（）调用告诉操作系统实际在磁盘上写入数据
＃而不是等待输出缓冲区中的更多数据。某些操作系统会真正刷新
＃磁盘上的数据，某些其他操作系统将尝试尽快进行处理。
＃
＃Redis支持三种不同的模式：
＃
＃否：不要fsync，只要让OS在需要时刷新数据即可。快点。
＃always：每次写入仅附加日志后，fsync。慢，最安全。
＃everysec：每秒仅同步一次fsync。妥协。
＃
＃默认值是“ everysec”，因为这通常是
＃速度和数据安全。您可以自行决定是否可以放松
＃“ no”将使操作系统在以下情况时刷新输出缓冲区
＃它希望获得更好的性能（但如果您可以接受
＃一些数据丢失会考虑默认的持久化模式（即快照），
＃或者相反，使用“ always”，它虽然很慢，但是比
＃每秒钟。
＃
＃更多详细信息，请查看以下文章：
＃http://antirez.com/post/redis-persistence-demystified.html
＃
＃如果不确定，请使用“ everysec”。

#appendfsync总是
appendfsync everysec
＃appendfsync否

＃当AOF fsync策略设置为always或everysec，并且有背景
＃保存过程（后台保存或AOF日志后台重写）为
＃在某些Linux配置中，对磁盘执行大量I / O
＃Redis可能在fsync（）调用中阻塞的时间过长。请注意，没有针对
＃当前，因为即使在其他线程中执行fsync也会阻塞
＃我们的同步write（2）调用。
＃
＃为了减轻此问题，可以使用以下选项
＃可以防止在主进程中调用fsync（）时
＃BGSAVE或BGREWRITEAOF正在进行中。
＃
＃这意味着当另一个孩子正在保存时，Redis的持久性是
＃与“ appendfsync none”相同。实际上，这意味着
＃在最坏的情况下可能会丢失多达30秒的日志记录（使用
＃默认Linux设置）。
＃
＃如果您有延迟问题，请将其设为“是”。否则将其保留为
从耐久性的角度来看，＃“ no”是最安全的选择。

no-appendfsync-on-rewrite否

＃自动重写仅附加文件。
＃Redis能够自动重写隐式调用的日志文件
＃BGREWRITEAOF，当AOF日志大小增加指定的百分比时。
＃
＃这是这样的：Redis会记住AOF文件的大小。
＃最新重写（如果重新启动后未发生任何重写，则为
＃使用启动时的AOF）。
＃
＃将此基本大小与当前大小进行比较。如果当前大小是
＃大于指定的百分比，将触发重写。也
＃您需要为要重写的AOF文件指定最小大小，这
＃即使在百分比增加的情况下也可以避免重写AOF文件
＃已达到，但仍然很小。
＃
＃指定零百分比以禁用自动AOF
＃重写功能。

自动改写百分比100
自动改写最小大小64mb

＃在Redis的最后发现AOF文件被截断
＃启动过程，当AOF数据重新加载到内存中时。
＃当运行Redis的系统时可能会发生
＃崩溃，尤其是在没有安装ext4文件系统的情况下
＃data = ordered选项（但是Redis本身不会发生这种情况
＃崩溃或中止，但操作系统仍可正常运行）。
＃
＃Redis可以在发生这种情况时退出并显示错误，也可以加载尽可能多的内容
＃尽可能的数据（现在是默认值），如果找到AOF文件则开始
＃在末尾被截断。以下选项控制此行为。
＃
＃如果aof-load-truncated设置为yes，则会加载截短的AOF文件并
＃Redis服务器开始发出日志以通知用户该事件。
＃否则，如果该选项设置为no，服务器将中止并显示错误
＃并拒绝启动。当选项设置为no时，用户要求
＃在重新启动之前使用“ redis-check-aof”实用程序修复AOF文件
＃ 服务器。
＃
＃请注意，如果在中间发现AOF文件已损坏
＃服务器仍将退出并出现错误。该选项仅在以下情况下适用
＃Redis将尝试从AOF文件中读取更多数据，但字节数不足
＃将被发现。
aof负载截断是

＃重写AOF文件时，Redis可以使用RDB前导中的
＃AOF文件可加快重写和恢复速度。启用此选项时
重写的AOF文件上的＃由两个不同的节组成：
＃
＃[RDB文件] [AOF尾巴]
＃
＃加载Redis时，会识别AOF文件以“ REDIS”开头
＃字符串并加载带前缀的RDB文件，并继续加载AOF
＃ 尾巴。
aof-use-rdb-preamble是

############################## LUA SCRIPTING ################# ###############

＃Lua脚本的最大执行时间（以毫秒为单位）。
＃
＃如果达到了最大执行时间，Redis将记录脚本是
＃在最长允许时间后仍在执行，并将开始执行
＃回复有错误的查询。
＃
＃当长时间运行的脚本超过最大执行时间时，仅
＃SCRIPT KILL和SHUTDOWN NOSAVE命令可用。第一个可以是
＃用于停止尚未调用写命令的脚本。第二
＃是在执行写命令的情况下关闭服务器的唯一方法
＃已由脚本发出，但用户不想等待自然
＃终止脚本。
＃
＃将其设置为0或负值以无警告地无限执行。
lua-time-limit 5000

############################### REDIS CLUSTER ################ ###############

＃普通Redis实例不能属于Redis集群；只有节点
＃在集群节点可以的情况下启动。为了启动一个Redis实例
＃cluster node使群集支持取消注释以下内容：
＃
＃已启用集群

＃每个群集节点都有一个群集配置文件。该文件不是
＃旨在手工编辑。它由Redis节点创建和更新。
＃每个Redis群集节点都需要一个不同的群集配置文件。
＃确保在同一系统上运行的实例没有
＃重叠的集群配置文件名。
＃
＃cluster-config-file节点-6379.conf

＃群集节点超时是节点必须无法访问的毫秒数
＃将其视为处于故障状态。
＃其他大多数内部时间限制是节点超时的倍数。
＃
＃cluster-node-timeout 15000

＃发生故障的主服务器的副本将避免在其数据出现时启动故障转移
＃看起来太旧了。
＃
＃没有简单的方法可以使副本实际具有精确的度量
＃它的“数据年龄”，因此执行以下两项检查：
＃
＃1）如果有多个副本可以进行故障转移，则它们交换消息
＃为了尝试使副本具有最佳优势
＃复制偏移量（已处理来自主服务器的更多数据）。
＃副本将尝试按偏移量获取排名，并应用于开始
故障转移的数量与它们的等级成正比的延迟。
＃
＃2）每个副本计算最后一次互动的时间
＃它的主人。这可以是最后收到的ping或命令（如果主服务器
＃仍处于“已连接”状态），或者自
＃与主服务器断开连接（如果复制链接当前断开）。
＃如果最后一次交互太旧，副本将不会尝试故障转移
＃一点。
＃
＃用户可以调整点“ 2”。具体来说，副本将无法执行
＃故障转移（如果自从与主机进行最后一次交互以来）
＃经过的次数大于：
＃
＃（节点超时*复制有效性因子）+ repl-ping-replica-period
＃
＃例如，如果node-timeout为30秒，并且副本有效性因子
＃为10，并假设默认的repl-ping-replica-period为10秒，则
如果无法与主副本进行通讯，则＃复制副本将不会尝试进行故障转移
＃超过310秒。
＃
＃较大的副本有效性因素可能允许数据过旧的副本进行故障转移
＃主机，但值太小可能会导致群集无法
＃完全选择一个副本。
＃
＃为了获得最大可用性，可以设置副本有效性因子
＃的值为0，这意味着副本将始终尝试对
＃master，无论他们上次与master互动的时间如何。
＃（但是，他们将始终尝试按比例施加延迟
＃偏移排名）。
＃
＃零是唯一能够保证所有分区恢复正常的值
＃群集将始终能够继续。
＃
＃cluster-replica-validity-factor 10

＃群集副本能够迁移到孤立的主数据库（即主数据库）
＃没有可用的副本。这提高了集群能力
＃抵抗失败，否则孤立的主节点无法进行故障转移
＃如果没有可用的副本则失败。
＃
＃仅当仍然存在至少一个副本时，副本服务器才会迁移到孤立的主服务器
＃给定其旧主副本的其他工作副本的数量。这个号码
＃是“移民壁垒”。迁移障碍为1表示副本
＃仅在其主数据库至少有其他1个工作副本时才会迁移
＃依此类推。它通常反映出每个副本所需的副本数
＃集群中的master。
＃
＃默认为1（仅当其主服务器保持至少
＃个副本）。要禁用迁移，只需将其设置为非常大的值即可。
＃可以设置为0，但仅在调试和危险时有用
＃生产中。
＃
＃cluster-migration-barrier 1

＃默认情况下，Redis群集节点如果检测到查询，则停止接受查询
＃至少是一个未显示的哈希槽（没有可用节点为其提供服务）。
＃如果集群部分关闭，则使用这种方式（例如，一定范围的哈希槽）
＃不再涵盖）所有群集最终将变得不可用。
＃重新覆盖所有插槽后，它将自动返回可用状态。
＃
＃但是有时您希望集群的子集正常工作，
＃继续接受对仍然存在的键空间部分的查询
＃覆盖。为此，只需设置cluster-require-full-coverage
＃选项为否。
＃
＃cluster-require-full-coverage是

＃此选项设置为yes时，可防止副本尝试对其进行故障转移
＃在主服务器故障期间的主服务器。但是主控仍然可以执行
＃手动故障转移（如果被迫这样做）。
＃
＃这在不同的情况下很有用，尤其是在多个情况下
＃数据中心操作，如果不希望的话，我们希望一侧永远不会升级
＃如果发生直流故障。
＃
＃cluster-replica-no-failover否

＃为了设置您的集群，请确保阅读文档
＃可从http://redis.io网站获得。

######################### CLUSTER DOCKER / NAT支持################### #####

＃在某些部署中，Redis群集节点地址发现失败，因为
＃个地址是NAT-ted或因为端口已转发（典型情况是
＃Docker和其他容器）。
＃
＃为了使Redis Cluster在这样的环境中工作，
＃每个节点都知道需要其公共地址的配置。该
＃以下两个选项用于此范围，分别是：
＃
＃*集群公告IP
＃*集群公告端口
＃*集群公告总线端口
＃
＃每个命令都向节点说明其地址，客户端端口和集群消息
＃总线端口。然后将信息发布在总线数据包的标题中
＃，以便其他节点能够正确映射该节点的地址
＃发布信息。
＃
＃如果未使用上述选项，则正常的Redis群集自动检测
＃将代替使用。
＃
＃请注意，重新映射后，总线端口可能不会位于
＃客户端端口+ 10000，因此您可以根据需要指定任何端口和总线端口
＃如何重新映射它们。如果未设置总线端口，则固定偏移量为
＃10000将照常使用。
＃
＃示例：
＃
＃cluster-announce-ip 10.1.1.5
＃cluster-announce-port 6379
＃cluster-announce-bus-port 6380

################################ SLOW LOG ############### #####################

＃Redis Slow Log是用于记录超过指定数量的查询的系统
＃ 执行时间处理时间。执行时间不包括I / O操作
＃喜欢与客户交谈，发送回复等，
＃但仅是实际执行命令所需的时间（这是唯一的时间
＃执行命令的阶段，其中线程被阻塞并且无法服务
同时＃个其他请求）。
＃
＃您可以使用以下两个参数配置慢速日志：一个告诉Redis
＃为了使执行时间超出多少时间（以微秒为单位）
＃命令获取日志，另一个参数是长度
＃慢日志。记录新命令时，最旧的命令将从
＃已记录命令的队列。

＃以下时间以微秒表示，因此1000000等价
＃一秒钟。请注意，负数将禁用慢速日志记录，而
＃零值将强制记录每个命令。
slowlog-log-慢于10000

＃此长度没有限制。请注意，它将消耗内存。
＃您可以使用SLOWLOG RESET回收慢速日志使用的内存。
slowlog-max-len 128

############################## LATENCY MONITOR ################# ##############

＃Redis延迟监控子系统对不同的操作进行采样
＃在运行时收集与可能的来源有关的数据
＃Redis实例的延迟。
＃
＃通过LATENCY命令，该信息对用户可用
＃打印图表并获取报告。
＃
＃系统仅记录在等于或等于时间的时间内执行的操作
＃大于通过指定的毫秒数
＃delay-monitor-threshold配置指令。设置其值时
＃设置为零，等待时间监视器关闭。
＃
＃默认情况下，延迟监视是禁用的，因为它几乎不需要
＃如果您没有延迟问题，并且收集数据可以提高性能
＃冲击虽然很小，但可以在大负载下测量。潜伏
使用以下命令可以在运行时轻松启用＃监视
＃“如果需要，请配置配置等待时间监控器阈值<毫秒”。
等待时间监控器阈值0

########################### EVENT NOTIFICATION #################### ###########

＃Redis可以将关键空间中发生的事件通知给发布/订阅客户端。
＃此功能记录在http://redis.io/topics/notifications
＃
＃例如，如果启用了键空间事件通知，并且客户端
＃对存储在数据库0中的键“ foo”执行DEL操作，两个
＃条消息将通过发布/订阅发布：
＃
＃发布__keyspace @ 0 __：foo del
＃发布__keyevent @ 0 __：del foo
＃
＃可以在一组中选择Redis将通知的事件
类数。每个类都由一个字符标识：
＃
＃K个键空间事件，以__keyspace @ <db> __前缀发布。
＃E Keyevent事件，以__keyevent @ <db> __前缀发布。
＃g通用命令（非类型专用），例如DEL，EXPIRE，RENAME，...
＃$字符串命令
＃l列出命令
＃s设置命令
＃h哈希命令
＃z排序集命令
＃x过期事件（每次密钥过期时生成的事件）
＃e驱逐事件（驱逐密钥以获取最大内存时生成的事件）
＃g $ lshzxe的别名，因此“ AKE”字符串表示所有事件。
＃
＃“ notify-keyspace-events”将由组成的字符串作为参数
零个或多个字符的数量。空字符串表示通知
＃被禁用。
＃
＃示例：从列表的角度启用列表和一般事件
＃事件名称，使用：
＃
＃notify-keyspace-events Elg
＃
＃示例2：获取订阅频道的过期密钥流
＃名称__keyevent @ 0__：过期使用：
＃
＃notify-keyspace-events Ex
＃
＃默认情况下，所有通知都被禁用，因为大多数用户不需要
＃此功能，该功能会有一些开销。请注意，如果您不
＃指定K或E中的至少一个，不会传送任何事件。
notify-keyspace-events“”

############################## GOPHER SERVER ################# ################

＃Redis包含Gopher协议的实现，如
＃RFC 1436（https://www.ietf.org/rfc/rfc1436.txt）。
＃
＃Gopher协议在90年代后期非常流行。这是一种替代
＃到网络上，服务器和客户端的实现是如此简单
＃Redis服务器只有100行代码才能实现此功能
＃支持。
＃
＃您现在如何使用Gopher？好吧，地鼠从来没有*真的*死过，并且
＃最近为了让Gopher具有更高层次的内容而进行了一些移动
＃由纯文本文档组成，将要复活。有些人想要更简单
＃互联网，其他人认为主流互联网变得太多了
＃控制，为那些
＃想要新鲜空气。
＃
＃无论如何，在Redis诞生10周年之际，我们给了它Gopher协议
＃作为礼物。
＃
＃  - - 这个怎么运作？---
＃
＃Redis Gopher支持使用Redis的内联协议，特别是
＃两种内联请求都是非法的：空请求
＃或任何以“ /”开头的请求（没有Redis命令开头
＃加上这样的斜线）。正常的RESP2 / RESP3请求完全超出了
＃通常是Gopher协议实现的路径。
＃
＃如果启用Gopher后打开与Redis的连接并发送
＃一个类似“ / foo”的字符串，如果有一个名为“ / foo”的密钥，则通过
＃Gopher协议。
＃
＃为了创建一个真正的Gopher“漏洞”（Gopher中Gopher网站的名称，
＃说话），您可能需要以下脚本：
＃
＃https://github.com/antirez/gopher2redis
＃
＃  - - 安全警告  - -
＃
＃如果您打算将Redis放在互联网上的公共地址中
＃到服务器Gopher页面上确保为实例设置密码。
＃设置密码后：
＃
＃1. Gopher服务器（启用时，默认情况下未启用）将终止服务
＃通过Gopher的内容。
＃2.但是，在客户端将无法调用其他命令之前
＃验证。
＃
＃因此，请使用'requirepass'选项保护您的实例。
＃
＃要启用Gopher支持，请取消注释以下行并进行设置
＃从no（默认）到yes的选项。
＃
＃启用gopher的否

############################## ADVANCED CONFIG ################# ##############

＃当散列具有
＃条目数量少，最大条目不超过给定
＃门槛。可以使用以下指令配置这些阈值。
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

＃列表也以特殊方式编码，以节省大量空间。
＃可以指定每个内部列表节点允许的条目数
＃作为固定的最大大小或最大元素数。
＃对于固定的最大大小，请使用-5到-1，表示：
＃-5：最大大小：64 Kb <-不建议用于正常工作负载
＃-4：最大大小：32 Kb <-不推荐
＃-3：最大大小：16 Kb <-可能不建议
＃-2：最大大小：8 Kb <-好
＃-1：最大大小：4 Kb <-好
＃正数表示最多存储_exactly_个元素
＃每个列表节点。
＃效果最好的选项通常是-2（8 Kb大小）或-1（4 Kb大小），
＃但如果您的用例是唯一的，请根据需要调整设置。
list-max-ziplist-size -2

＃列表也可能被压缩。
＃压缩深度是从*每个*侧面开始的快速列表ziplist节点的数量
＃要从压缩中“排除”的列表。列表的首尾
＃始终未压缩以进行快速推入/弹出操作。设置为：
＃0：禁用所有列表压缩
＃1：深度1表示“直到列表中的1个节点之后才开始压缩，
＃从头到尾”
＃因此：[head]-> node-> node-> ...-> node-> [tail]
＃[head]，[tail]将始终未压缩；内部节点将压缩。
＃2：[head]-> [next]-> node-> node-> ...-> node-> [prev]-> [tail]
这里的＃2表示：请勿压缩head或head-> next或tail-> prev或tail，
＃但压缩它们之间的所有节点。
＃3：[head]-> [next]-> [next]-> node-> node-> ...-> node-> [prev]-> [prev]-> [tail]
＃等
list-compress-depth 0

＃集合在一种情况下具有特殊的编码：组成集合时
恰好是基数10范围内的整数的字符串的数量
64位带符号整数的数量。
＃以下配置设置设置了大小限制
＃设置为使用此特殊的内存保存编码。
设置最大整数项512

＃与散列和列表类似，对排序集也进行了特殊编码
＃为了节省很多空间。仅当长度和
排序集中的＃个元素低于以下限制：
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

＃HyperLogLog稀疏表示字节数限制。该限制包括
＃16个字节的标头。当使用稀疏表示的HyperLogLog交叉时
＃此限制，它将转换为密集表示形式。
＃
＃大于16000的值完全没有用，因为此时
＃密集表示可提高内存效率。
＃
＃为了获得以下好处，建议值是〜3000
＃节省空间的编码而不会减慢PFADD，
＃是稀疏编码的O（N）。该值可以提高到
＃〜10000，当CPU不是问题，而是空间，并且数据集为
＃由许多基数在0-15000范围内的HyperLogLog组成。
hll-sparse-max-bytes 3000

＃流宏节点的最大大小/项目。流数据结构是一个基数
＃大节点树，对内部的多个项目进行编码。使用此配置
＃可以配置单个节点的字节数，并且
＃在以下情况下切换到新节点之前可能包含的最大项目数：
＃附加新的流条目。如果以下任何设置被设置为
＃零，该限制被忽略，因此例如可以设置一个
＃通过将max-bytes设置为0并将max-entries设置为所需的最大整数限制
＃值。
流节点最大字节数4096
流节点最大条目数100

＃主动重新哈希处理每100毫秒CPU时间使用1毫秒
＃为了帮助重新哈希主Redis哈希表（一个映射顶层）
＃个值键）。Redis使用的哈希表实现（请参见dict.c）
＃执行一次懒散的重新哈希处理：您在哈希表中运行的操作更多
＃即要进行哈希处理的代码，将执行更多哈希处理的“步骤”，因此，如果
＃服务器处于空闲状态，重新哈希处理从未完成，并且使用了更多内存
＃通过哈希表。
＃
＃默认值是每秒使用此毫秒10次，以便
＃主动重新哈希主字典，并在可能的情况下释放内存。
＃
＃如果不确定：
＃如果您有严格的延迟要求，请使用“ activerehashing no”
＃在您的环境中，Redis可以不时回复，这不是一件好事
＃查询2毫秒的延迟。
＃
＃如果您没有如此严格的要求，请使用“ activerehashing yes”
＃希望在可能的情况下尽快释放内存。
主动重新哈希是

＃客户端输出缓冲区限制可用于强制断开客户端连接
＃由于某种原因没有足够快地从服务器读取数据（a
＃常见原因是发布/订阅客户端无法像使用邮件一样快地消费邮件
＃发布者可以制作它们）。
＃
＃可以为三种不同类别的客户端设置不同的限制：
＃
＃普通->普通客户端，包括MONITOR客户端
＃副本->副本客户端
＃pubsub->客户端订阅了至少一个pubsub频道或模式
＃
＃每个client-output-buffer-limit指令的语法如下：
＃
＃client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
＃
＃一旦达到硬限制，或者如果
＃达到软限制，并保持达到指定数量
＃秒（连续）。
＃例如，如果硬限制为32 MB，软限制为
＃16兆字节/ 10秒，客户端将立即断开连接
＃如果输出缓冲区的大小达到32 MB，但也会
＃如果客户端达到16兆字节并持续克服，则断开连接
＃10秒的限制。
＃
＃默认情况下，普通客户端不受限制，因为它们不接收数据
＃不询问（以推送方式），而是在请求之后，因此仅
＃异步客户端可能会创建一个场景，在该场景中，数据请求速度更快
＃比它能读的多。
＃
＃相反，对于pubsub和副本客户端没有默认限制，因为
＃个订阅者和副本以推送方式接收数据。
＃
＃可以通过将硬限制或软限制设置为零来禁用它们。
客户端输出缓冲区限制正常0 0 0
客户端输出缓冲区限制副本256mb 64mb 60
客户端输出缓冲区限制pubsub 32mb 8mb 60

＃客户端查询缓冲区累积新命令。它们仅限于固定
默认情况下为＃数量，以避免协议失步（对于
＃实例（由于客户端中的错误）会导致未绑定的内存使用情况
＃查询缓冲区。但是，如果您有特殊要求，可以在此处进行配置
＃需求，例如我们巨大的multi / exec请求等等。
＃
＃client-query-buffer-limit 1gb

＃在Redis协议中，批量请求即表示单个请求的元素
＃个字符串，通常限制为512 mb以上。但是您可以更改此限制
＃ 这里。
＃
＃proto-max-bulk-len 512mb

＃Redis调用内部函数来执行许多后台任务，例如
＃在超时时关闭客户端连接，清除已过期的密钥
＃从未提出要求，依此类推。
＃
＃并非所有任务都以相同的频率执行，但是Redis会检查
＃根据指定的“ hz”值执行的任务。
＃
＃默认情况下，“ hz”设置为10。
＃Redis处于空闲状态，但同时会使Redis在
＃有许多键同时到期，并且可能超时
＃更精确地处理。
＃
＃范围在1到500之间，但是通常不超过100
＃ 一个好主意。大多数用户应使用默认值10并将其提高到
＃100仅在要求极低延迟的环境中使用。
hz 10

＃通常，将HZ值与
＃连接的客户端数。这很有用，例如
＃避免为每个后台任务调用处理过多的客户端
＃为了避免延迟尖峰。
＃
＃由于默认的默认HZ值保守地设置为10，因此Redis
＃提供并默认启用使用自适应HZ值的功能
＃当有许多连接的客户端时，它将暂时提高。
＃
＃启用动态HZ时，实际配置的HZ将用作
＃作为基准，但实际配置的HZ值的倍数将是
＃在连接更多客户端后根据需要使用。这样闲置
＃实例将仅占用很少的CPU时间，而繁忙的实例将
＃更灵敏。
动态HZ是

＃当孩子重写AOF文件时，如果启用以下选项
＃每生成32 MB的数据，文件就会进行同步处理。这很有用
＃为了更逐步地将文件提交到磁盘并避免
＃大的延迟峰值。
aof-rewrite-incremental-fsync是

＃Redis保存RDB文件时，如果启用以下选项
＃每生成32 MB的数据，文件就会进行同步处理。这很有用
＃为了更逐步地将文件提交到磁盘并避免
＃大的延迟峰值。
rdb-save-incremental-fsync是

＃可以调整Redis LFU逐出（请参阅maxmemory设置）。但是，这是一个很好的
＃从默认设置开始的想法，只有在调查后才能更改它们
＃如何提高性能以及LFU键随时间变化的方式，其中
＃可以通过OBJECT FREQ命令检查。
＃
＃Redis LFU实现中有两个可调参数：
＃计数器对数因子和计数器衰减时间。重要的是要
＃在更改它们之前了解两个参数的含义。
＃
＃LFU计数器每个密钥只有8位，最大值为255，因此Redis
＃使用具有对数行为的概率增量。赋予价值
＃旧计数器的编号，当访问一个键时，该计数器递增
＃ 这条路：
＃
＃1.提取介于0和1之间的随机数R。
＃2。将概率P计算为1 /（old_value * lfu_log_factor + 1）。
＃3.仅当R <P时，计数器才会递增。
＃
＃默认的lfu-log-factor是10。这是一个频率表
＃计数器随着访问次数的不同而变化，且访问次数不同
＃对数因子：
＃
＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +
＃| 因素 100点击| 1000点击| 10万点击| 1M点击| 1000万次点击|
＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +
＃| 0 | 104 | 255 | 255 | 255 | 255 |
＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +
＃| 1 | 18 | 49 | 255 | 255 | 255 |
＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +
＃| 10 | 10 | 18 | 142 | 255 | 255 |
＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +
＃| 100 | 8 | 11 | 49 | 143 | 255 |
＃+ -------- + ------------ + ------------ + ------------ + ------------ + ------------ +
＃
＃注意：上表是通过运行以下命令获得的：
＃
＃redis-benchmark -n 1000000 incr foo
＃redis-cli对象freq foo
＃
＃注意2：计数器的初始值为5，以便为新对象提供机会
＃累积点击数。
＃
＃计数器衰减时间是按顺序必须经过的时间（以分钟为单位）
＃将密钥计数器除以2（如果有值则减1
＃小于<= 10）。
＃
＃lfu-decay-time的默认值为1。特殊值0表示
＃每次碰巧扫描计数器时都会使其衰减。
＃
＃lfu-log-factor 10
＃lfu-decay-time 1

##########################活动碎片###################### ##
＃
＃警告此功能是实验性的。然而，这是经过压力测试的
＃甚至在生产中，并由多名工程师手动测试
＃ 时间。
＃
＃什么是主动碎片整理？
＃-------------------------------
＃
＃主动（在线）碎片整理允许Redis服务器压缩
＃在内存中的小量分配和释放之间留有空格，
＃从而允许回收内存。
＃
＃碎片是每个分配器都会发生的自然过程（但
＃幸运的是，Jemalloc和某些工作负载更少。通常是一台服务器
＃重新启动是必需的，以减少碎片或至少冲洗
＃删除所有数据并再次创建。但是由于这个功能
＃由Oran Agra针对Redis 4.0实施，此过程可以在运行时发生
＃在服务器运行时以“热”方式。
＃
＃基本上在碎片超过一定水平时（请参阅
＃下面的配置选项），Redis将开始创建新的副本
通过利用某些特定的Jemalloc在连续内存区域中的＃值
＃功能（以了解分配是否引起碎片
＃并将其分配到一个更好的位置），同时释放
＃数据的旧副本。对所有键逐步重复此过程
＃将导致碎片恢复到正常值。
＃
＃重要事项：
＃
＃1.默认情况下，此功能处于禁用状态，仅在编译Redis时有效
＃使用我们随附Redis源代码的Jemalloc副本。
＃这是Linux构建的默认设置。
＃
＃2.如果没有碎片，则无需启用此功能
＃个问题。
＃
＃3。一旦遇到碎片，您可以在以下情况启用此功能：
＃需要使用命令“ CONFIG SET activedefrag yes”。
＃
＃配置参数能够微调
＃碎片整理过程。如果您不确定它们是什么意思
＃保持默认值不变的好主意。

＃启用主动碎片整理
＃activedefrag是

＃启动主动碎片整理的最小碎片浪费
＃active-defrag-ignore-bytes 100mb

＃启动活动碎片整理的最小碎片百分比
＃active-defrag-threshold-lower 10

＃我们最大程度地努力下的最大碎片百分比
＃active-defrag-threshold-upper 100

＃减少CPU碎片整理的工作量
＃active-defrag-cycle-min 5

＃尽最大努力整理CPU百分比
＃active-defrag-cycle-max 75

＃将要处理的set / hash / zset / list字段的最大数量
＃主字典扫描
＃active-defrag-max-scan-fields 1000
